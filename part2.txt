========================================Solution to 2.1========================================
Without a command devopsdockeruh/simple-web-service will create logs into its /usr/src/app/text.log.
Create a docker-compose.yml file that starts devopsdockeruh/simple-web-service and saves the logs into your filesystem.
Submit the docker-compose.yml, make sure that it works simply by running docker-compose up if the log file exists.

# Remember to create this file first **
Terminal 1: % touch text.log

Terminal 1: % cat docker-compose.yml
version: '3.2'

services:
    simple-web-service:
      image: devopsdockeruh/simple-web-service
      build: .
      volumes:
        - ./text.log:/usr/src/app/text.log
      container_name: simple-web-service

Terminal 1: % tail -f text.log

Terminal 2: % docker-compose up
[+] Running 1/1
 ⠿ Container simple-web-service  Recreated                                                                                      0.2s
Attaching to simple-web-service
simple-web-service  | Starting log output
simple-web-service  | Wrote text to /usr/src/app/text.log
simple-web-service  | Wrote text to /usr/src/app/text.log
....

Terminal 1: % tail -f text.log
2021-10-23 12:04:05 +0000 UTC
2021-10-23 12:04:07 +0000 UTC
2021-10-23 12:04:09 +0000 UTC
2021-10-23 12:04:11 +0000 UTC
2021-10-23 12:04:13 +0000 UTC
Secret message is: 'You can find the source code here: https://github.com/docker-hy'
....

========================================Solution to 2.2========================================
The familiar image devopsdockeruh/simple-web-service can be used to start a web service.
Create a docker-compose.yml and use it to start the service so that you can use it with your browser.
Submit the docker-compose.yml, make sure that it works simply by running docker-compose up

# Remember to create this file first **
Terminal 1: % touch text.log

Terminal 1: % cat docker-compose.yml
version: '3.2'

services:
    simple-web-service:
      image: devopsdockeruh/simple-web-service
      working_dir: /usr/src/app/
      build: .
      volumes:
        - ./text.log:/usr/src/app/text.log
      command: server
      ports:
        - '8888:8080'
      container_name: simple-web-service

Terminal 1: % docker-compose up
[+] Running 1/1
 ⠿ Container simple-web-service  Recreated                                                                                      0.1s
Attaching to simple-web-service
simple-web-service  | [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.
simple-web-service  |
simple-web-service  | [GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
simple-web-service  |  - using env:	export GIN_MODE=release
simple-web-service  |  - using code:	gin.SetMode(gin.ReleaseMode)
simple-web-service  |
simple-web-service  | [GIN-debug] GET    /*path                    --> server.Start.func1 (3 handlers)
simple-web-service  | [GIN-debug] Listening and serving HTTP on :8080

Terminal 2: % curl 127.0.0.1:8888
{"message":"You connected to the following path: /","path":"/"}%

========================================Solution to 2.3========================================
In the previous part we created Dockerfiles for both frontend and backend. Next, simplify the usage into one docker-compose.yml.
Configure the backend and frontend from part 1 to work in docker-compose. Submit the docker-compose.yml

% docker images
REPOSITORY                          TAG       IMAGE ID       CREATED        SIZE
example-backend-env                 latest    a43a04d205ab   23 hours ago   987MB
example-frontend-env                latest    356aaf19396e   23 hours ago   1.21GB

% cat docker-compose.yml
version: '3.2'

services:
    frontend:
      image: example-frontend-env
      build: .
      ports:
        - '5000:5000'
      container_name: frontend
    backend:
      image: example-backend-env
      build: .
      ports:
        - '8080:8080'
      container_name: backend

% docker-compose up
[+] Running 2/2
 ⠿ Container backend   Recreated                                                                                                         0.2s
 ⠿ Container frontend  Recreated                                                                                                         0.2s
Attaching to backend, frontend
backend   | [Ex 2.4+] REDIS_HOST env was not passed so redis connection is not initialized
backend   | [Ex 2.6+] POSTGRES_HOST env was not passed so postgres connection is not initialized
backend   | [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.
backend   |
backend   | [GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
backend   |  - using env:	export GIN_MODE=release
backend   |  - using code:	gin.SetMode(gin.ReleaseMode)
backend   |
backend   | [GIN-debug] GET    /ping                     --> server/router.pingpong (4 handlers)
backend   | [GIN-debug] GET    /messages                 --> server/controller.GetMessages (4 handlers)
backend   | [GIN-debug] POST   /messages                 --> server/controller.CreateMessage (4 handlers)
backend   | [GIN-debug] Listening and serving HTTP on :8080
frontend  | WARNING: Checking for updates failed (use `--debug` to see full error)
frontend  | INFO: Accepting connections at http://localhost:5000

# Input "http://127.0.0.1:5000/" in the browser, 
Exercise 1.12: Congratulations! You configured your ports correctly!
Click "PRESS TO TEST!" button next to "Exercise 1.14" in the website, the following info can be seen:
"Success! Great job!"

========================================Solution to 2.4========================================
Add redis to example backend. Redis is used to speed up some operations.
Backend uses a slow api to get information. You can test the slow api by requesting /ping?redis=true with curl. The frontend program has a button to test this.
Configure a redis container to cache information for the backend. Use the documentation if needed when configuring: https://hub.docker.com/_/redis/
The backend README should have all the information needed to connect. When you’ve correctly configured the button will turn green.
Submit the docker-compose.yml

Note:
# https://stackoverflow.com/questions/42360356/docker-redis-connection-refused
# each docker compose container can access other container by using the service name as hostname. 

% cat docker-compose.yml_bak
version: '3.2'

services:
    frontend:
      image: example-frontend-env
      build: .
      ports:
        - '5000:5000'
      container_name: frontend
    backend:
      image: example-backend-env
      environment:
          REDIS_HOST: redis
      build: .
      ports:
        - '8080:8080'
      container_name: backend
      depends_on:
        - redis
    redis:
      image: redis
      build: .
      ports:
        - '6379:6379'
      restart: unless-stopped
      container_name: redis

% docker-compose up
[+] Running 3/3
 ⠿ Container frontend  Created                                                                                                                        0.1s
 ⠿ Container redis     Created                                                                                                                        0.1s
 ⠿ Container backend   Created                                                                                                                        0.1s
Attaching to backend, frontend, redis
redis     | 1:C 23 Oct 2021 13:34:57.243 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
redis     | 1:C 23 Oct 2021 13:34:57.243 # Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=1, just started
redis     | 1:C 23 Oct 2021 13:34:57.243 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf
redis     | 1:M 23 Oct 2021 13:34:57.244 * monotonic clock: POSIX clock_gettime
redis     | 1:M 23 Oct 2021 13:34:57.245 * Running mode=standalone, port=6379.
redis     | 1:M 23 Oct 2021 13:34:57.245 # Server initialized
redis     | 1:M 23 Oct 2021 13:34:57.246 * Ready to accept connections
backend   | [Ex 2.4+] Initializing redis client
backend   | [Ex 2.4+] Connection to redis initialized, ready to ping pong.
backend   | [Ex 2.6+] POSTGRES_HOST env was not passed so postgres connection is not initialized
backend   | [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.
backend   |
backend   | [GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
backend   |  - using env:	export GIN_MODE=release
backend   |  - using code:	gin.SetMode(gin.ReleaseMode)
backend   |
backend   | [GIN-debug] GET    /ping                     --> server/router.pingpong (4 handlers)
backend   | [GIN-debug] GET    /messages                 --> server/controller.GetMessages (4 handlers)
backend   | [GIN-debug] POST   /messages                 --> server/controller.CreateMessage (4 handlers)
backend   | [GIN-debug] Listening and serving HTTP on :8080
frontend  | INFO: Accepting connections at http://localhost:5000

# Input "http://127.0.0.1:5000/" in the browser, 
Click "PRESS TO TEST!" button next to "Exercise 2.4" in the website, the following info can be seen:
"Nice! The exercise is complete!"

# Input "http://127.0.0.1:8080/ping?redis=true" in the browser, "pong" can be seen in the website

========================================Solution to 2.5========================================
A project over at https://github.com/docker-hy/material-applications/tree/main/scaling-exercise has a hardly working application. Go ahead and clone it for yourself. The project already includes docker-compose.yml so you can start it by running docker-compose up.
Application should be accessible through http://localhost:3000. However it doesn’t work well enough and I’ve added a load balancer for scaling. Your task is to scale the compute containers so that the button in the application turns green.
This exercise was created with Sasu Mäkinen, Please return the used commands for this exercise.

From the README.md, "You just need to scale the compute service so that a large number of calculations gets distributed between a large number of compute services."
Tested the following 2 cmds, both can see the "Congratulations!" after clicking "Press here to test your solution" in the browser with "127.0.0.1:3000".
% docker-compose up --scale compute=3
% docker-compose up --scale compute=2